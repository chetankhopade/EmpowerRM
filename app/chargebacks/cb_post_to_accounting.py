import datetime
import json
import os
from decimal import Decimal
from operator import itemgetter

from django.contrib.auth.decorators import login_required
from django.core.files import File
from django.db import transaction
from django.http import HttpResponseRedirect
from django.urls import reverse
from django.views.decorators.csrf import csrf_exempt

from app.integrations.acumatica import AcumaticaRestService
from app.integrations.dynamics365 import Dynamics365aRestService
from app.management.utilities.constants import (SUBSTAGE_TYPE_ERRORS, STAGE_TYPE_VALIDATED,
                                                SUBSTAGE_TYPE_NO_ERRORS, STAGE_TYPE_POSTED,
                                                ACCOUNTING_TRANSACTION_STATUS_PENDING,
                                                ACCOUNTING_TRANSACTION_STATUS_RECEIVED,
                                                ACCOUNTING_TRANSACTION_STATUS_SENT,
                                                AUDIT_TRAIL_CHARGEBACK_ACTION_POST_TO_ACCOUNTING,
                                                SUBSTAGE_TYPE_WAITING_FOR_RESPONSE)
from app.management.utilities.functions import (ok_json, bad_json, convert_string_to_date, audit_trail, get_ip_address,
                                                chargeback_audit_trails)
from app.management.utilities.globals import addGlobalData
from erms.models import (ChargeBack, AccountingTransaction, AccountingError)


# # # # # NONE Handler # # # # #
@login_required(redirect_field_name='ret', login_url='/login')
def none_handler(request):
    # Ticket 877 new Accounting Integration called 'None'
    data = {'title': 'Chargebacks - Post to Accounting - None'}
    addGlobalData(request, data)

    if not data['company'] or not data['has_access_to_company']:
        return HttpResponseRedirect(reverse('companies'))

    try:
        with transaction.atomic():

            chargebacks_ids = request.POST['chargebacks_ids']
            post_date = convert_string_to_date(request.POST['post_date'])

            count_of_cbs = 0
            for chargeback_id in chargebacks_ids.split("|"):
                chargeback = ChargeBack.objects.get(id=chargeback_id)
                cb_claim_amount_issue = chargeback.claim_issue if chargeback.claim_issue else Decimal('0.00')

                # Validation (Ticket EA-637 and EA-785 exclude CBs with CM info)
                # ticket 998 added condition: If a CB has pending lines, do not allow user to Post to accounting
                if not chargeback.has_chargebacks_lines_with_pending_status() and chargeback.stage == STAGE_TYPE_VALIDATED and chargeback.substage == SUBSTAGE_TYPE_NO_ERRORS and not chargeback.accounting_credit_memo_number and not chargeback.accounting_credit_memo_date:

                    cbid = chargeback.cbid
                    customer = chargeback.get_my_customer()

                    # Ticket 983 Generated CM numbers should use the format CB+[CBID] (use 8 digits and leading zeros)
                    # For example if CBID is 1006 the CM number would be CB00001006.
                    if customer and customer.nocredit:
                        accounting_credit_memo_number = "NOCREDIT"
                    else:
                        cbid_str = str(cbid).zfill(8)
                        accounting_credit_memo_number = f"CB{cbid_str}"

                    # Ticket 877 fills out the 3 CM_ fields in the chargeback with the CM date, CM Number (generated by Empower) and CM Issued Amt
                    chargeback.accounting_credit_memo_number = accounting_credit_memo_number
                    chargeback.accounting_credit_memo_amount = cb_claim_amount_issue
                    chargeback.accounting_credit_memo_date = post_date
                    # Ticket 877 Mark CB as Posted / No Errors
                    chargeback.stage = STAGE_TYPE_POSTED
                    chargeback.substage = SUBSTAGE_TYPE_NO_ERRORS
                    chargeback.save()

                    count_of_cbs += 1

                    # Audit Trail
                    # audit_trail(username=request.user.username,
                    #             action=AUDIT_TRAIL_CHARGEBACK_ACTION_POST_TO_ACCOUNTING,
                    #             ip_address=get_ip_address(request),
                    #             entity1_name=chargeback.__class__.__name__,
                    #             entity1_id=chargeback.get_id_str(),
                    #             entity1_reference=chargeback.cbid)
                    # EA -EA-1548 New Chargeback Audit
                    change_text = f"{request.user.email} ran action {AUDIT_TRAIL_CHARGEBACK_ACTION_POST_TO_ACCOUNTING}"
                    chargeback_audit_trails(cbid=chargeback.get_id_str(),
                                            user_email=request.user.email,
                                            change_text=change_text,
                                            )
            return ok_json(data={
                'message': 'Integration System None has been applied changes to cbs',
                'count_of_cb_without_errors': count_of_cbs
            })

    except Exception as ex:
        print(ex.__str__())
        return bad_json(message=ex.__str__())


# # # # # MANUAL Handler # # # # #
@login_required(redirect_field_name='ret', login_url='/login')
def manual_handler(request):
    data = {'title': 'Chargebacks - Post to Accounting - Manual'}
    addGlobalData(request, data)

    if not data['company'] or not data['has_access_to_company']:
        return HttpResponseRedirect(reverse('companies'))

    try:
        with transaction.atomic():

            chargebacks_ids = request.POST['chargebacks_ids']
            post_date = convert_string_to_date(request.POST['post_date'])

            file_name = f"qb_{datetime.datetime.today().strftime('%Y%m%d%H%M%S%f')}.txt"

            items_without_accno = []
            with open(file_name, 'w') as myfile:  # open file (write mode)
                for chargeback_id in chargebacks_ids.split("|"):
                    chargeback = ChargeBack.objects.get(id=chargeback_id)
                    cb_claim_amount_issue = chargeback.claim_issue if chargeback.claim_issue else 0

                    # Validation (Ticket EA-637 and EA-785 exclude CBs with CM info)
                    # ticket 998 added condition: If a CB has pending lines, do not allow user to Post to accounting
                    if not chargeback.has_chargebacks_lines_with_pending_status() and chargeback.substage == SUBSTAGE_TYPE_NO_ERRORS and not chargeback.accounting_credit_memo_number and not chargeback.accounting_credit_memo_date:

                        cbid = chargeback.cbid
                        cb_number = chargeback.number
                        customer = chargeback.get_my_customer()
                        customer_accno = customer.account_number if customer else 'N/A'

                        # Ticket: EA-593 When a CB has a zero Claim Amount do not include it in the file creation
                        if cb_claim_amount_issue != 0:

                            for cbline in chargeback.get_my_chargeback_lines():
                                item = cbline.get_my_item()
                                item_ndc = item.ndc if item else 'N/A'
                                item_accno = item.account_number if item else 'N/A'
                                if not item_accno:
                                    items_without_accno.append(item_ndc)
                                item_qty = cbline.item_qty
                                item_amount_issue = Decimal(cbline.claim_amount_issue) if cbline.claim_amount_issue else Decimal('0.00')

                                # CBID, Customer_Id, Post_Date, Debit_Memo_Number, Total_Claim_Amt_Issue, Payment_Terms, Product_Id, Quantity, Amount
                                row = f"{cbid}" \
                                    f"|{customer_accno}" \
                                    f"|{post_date.strftime('%Y%m%d')}" \
                                    f"|{cb_number}" \
                                    f"|{cb_claim_amount_issue}" \
                                    f"|Due on receipt" \
                                    f"|{item_accno}" \
                                    f"|{item_qty}" \
                                    f"|{item_amount_issue}"

                                # write row
                                myfile.write(f"{row}\n")

                        else:
                            # Ticket 844 If nocredit Enabled, put NOCREDIT in CM field
                            # If Disabled, CM field put text NOCM concatenated with CBNumber (NOCM{CBnumber})
                            if customer.nocredit:
                                accounting_credit_memo_number = "NOCREDIT"
                            else:
                                accounting_credit_memo_number = f"NOCM{cb_number}"

                            chargeback.accounting_credit_memo_number = accounting_credit_memo_number
                            chargeback.accounting_credit_memo_amount = Decimal('0.00')
                            chargeback.accounting_credit_memo_date = post_date
                            chargeback.stage = STAGE_TYPE_POSTED
                            chargeback.substage = SUBSTAGE_TYPE_NO_ERRORS
                            chargeback.save()

                        # Audit Trail
                        # audit_trail(username=request.user.username,
                        #             action=AUDIT_TRAIL_CHARGEBACK_ACTION_POST_TO_ACCOUNTING,
                        #             ip_address=get_ip_address(request),
                        #             entity1_name=chargeback.__class__.__name__,
                        #             entity1_id=chargeback.get_id_str(),
                        #             entity1_reference=chargeback.cbid)
                        # EA -EA-1548 New Chargeback Audit
                        change_text = f"{request.user.email} ran action {AUDIT_TRAIL_CHARGEBACK_ACTION_POST_TO_ACCOUNTING}"
                        chargeback_audit_trails(cbid=chargeback.get_id_str(),
                                                user_email=request.user.email,
                                                change_text=change_text,
                                                )
                if items_without_accno:
                    if myfile.closed:
                        os.remove(myfile.name)
                    return bad_json(extradata=items_without_accno)

            # open file (read mode)
            with open(file_name, 'r') as myfile:
                data['company'].last_quickbook_file.save(file_name, File(myfile))

            if myfile.closed:
                os.remove(myfile.name)

            return ok_json(data={
                'message': 'A txt file with chargebacks information has been created to be imported into QuickBooks',
                'file_name': file_name,
                'file_path': data['company'].download_quickbook_file()
            })

    except Exception as ex:
        print(ex.__str__())
        return bad_json(message=ex.__str__())


# # # # # QUICKBOOKS Handler # # # # #
@login_required(redirect_field_name='ret', login_url='/login')
def quickbooks_handler(request):
    data = {'title': 'Chargebacks - Post to Accounting - Quickbooks Local'}
    addGlobalData(request, data)

    if not data['company'] or not data['has_access_to_company']:
        return HttpResponseRedirect(reverse('companies'))

    try:
        with transaction.atomic():

            chargebacks_ids = request.POST['chargebacks_ids']
            post_date = convert_string_to_date(request.POST['post_date'])

            count_of_cb_without_errors = 0
            items_without_accno = []
            for chargeback_id in chargebacks_ids.split("|"):
                chargeback = ChargeBack.objects.get(id=chargeback_id)
                cb_claim_amount_issue = chargeback.claim_issue if chargeback.claim_issue else 0

                if not chargeback.has_chargebacks_lines_with_pending_status():

                    if (chargeback.stage == STAGE_TYPE_VALIDATED and chargeback.substage == SUBSTAGE_TYPE_NO_ERRORS) or (chargeback.stage == STAGE_TYPE_POSTED and chargeback.substage == SUBSTAGE_TYPE_ERRORS):    # ticket 868

                        cbid = chargeback.cbid
                        cb_number = chargeback.number
                        customer = chargeback.get_my_customer()
                        customer_accno = customer.account_number if customer else 'N/A'

                        if cb_claim_amount_issue != 0:
                            # update Accounting Transaction table
                            acct_transaction = AccountingTransaction(cbid=cbid,
                                                                     cb_number=cb_number,
                                                                     cb_amount_issue=cb_claim_amount_issue,
                                                                     customer_accno=customer_accno,
                                                                     post_date=post_date,
                                                                     status=ACCOUNTING_TRANSACTION_STATUS_PENDING,
                                                                     integration_type='Q')
                            acct_transaction.save()

                            items = []
                            for cbline in chargeback.get_my_chargeback_lines():
                                item = cbline.get_my_item()
                                item_ndc = item.ndc if item else None
                                if item and item.ndc and 'NN' not in cbline.get_my_disputes_codes_list():
                                    if not item.account_number:
                                        items_without_accno.append(item_ndc)
                                    else:
                                        # add item data
                                        items.append({
                                            "account_number": item.account_number,
                                            "quantity": cbline.item_qty,
                                            "amount_issue": float(cbline.claim_amount_issue) if cbline.claim_amount_issue else 0,
                                        })

                            # add items to json field in qbcb
                            acct_transaction.items = items
                            acct_transaction.save()

                            # Ticket EA-743 Update CB to stage = 3 and substage 2 when the API sends a transaction to Quickbooks
                            chargeback.stage = STAGE_TYPE_POSTED
                            chargeback.substage = SUBSTAGE_TYPE_WAITING_FOR_RESPONSE
                            chargeback.save()

                        else:
                            # Ticket 844 If nocredit Enabled, put NOCREDIT in CM field
                            # If Disabled, CM field put text NOCM concatenated with CBNumber (NOCM{CBnumber})
                            if customer.nocredit:
                                accounting_credit_memo_number = "NOCREDIT"
                            else:
                                accounting_credit_memo_number = f"NOCM{cb_number}"

                            chargeback.accounting_credit_memo_number = accounting_credit_memo_number
                            chargeback.accounting_credit_memo_amount = Decimal('0.00')
                            chargeback.accounting_credit_memo_date = post_date
                            chargeback.stage = STAGE_TYPE_POSTED
                            chargeback.substage = SUBSTAGE_TYPE_NO_ERRORS
                            chargeback.save()

                        count_of_cb_without_errors += 1

            if items_without_accno:
                return bad_json(extradata=items_without_accno)

            return ok_json(data={
                'message': 'Chargebacks info has been saved to be used by QuickBooks via APIs integration',
                "count_of_cb_without_errors": count_of_cb_without_errors,
            })

    except Exception as ex:
        return bad_json(message=ex.__str__())


# # # # # ACUMATICA Handler # # # # #
@login_required(redirect_field_name='ret', login_url='/login')
@csrf_exempt
def acumatica_connection(request):
    data = {'title': 'Chargebacks - Post to Accounting - Acumatica Connection'}
    addGlobalData(request, data)
    try:
        # create an AcumaticaRestService instance (login and get session)
        rs = AcumaticaRestService(config=data['company'].integration_config)
        if not rs.connected:
            return bad_json(message='Error connecting to Acumatica')
        return ok_json()
    except Exception as ex:
        return bad_json(message=ex.__str__())


@login_required(redirect_field_name='ret', login_url='/login')
@csrf_exempt
def acumatica_validations(request):
    data = {'title': 'Chargebacks - Post to Accounting - Acumatica Validations'}
    addGlobalData(request, data)

    try:
        # Validations vs Acumatica (Customers and Items)
        rs = AcumaticaRestService(config=data['company'].integration_config)
        if not rs.connected:
            return bad_json(message='Error connecting to Acumatica')

        # Get Accumatica Customers and Items for validations
        acumatica_customers_ids_list = rs.get_active_customers_ids()
        acumatica_items_ids_list = rs.get_active_items_ids()

        cbs_with_wrong_customers = []
        cbs_with_wrong_items = []
        cbs_with_existing_transactions = []
        for chargeback_id in request.POST['chargebacks_ids'].split("|"):
            chargeback = ChargeBack.objects.get(id=chargeback_id)
            cbid = chargeback.cbid
            cb_claim_amount_issue = Decimal(chargeback.claim_issue) if chargeback.claim_issue else Decimal('0.00')
            customer = chargeback.get_my_customer()
            customer_accno = customer.account_number if customer else 'N/A'

            if chargeback.stage == STAGE_TYPE_VALIDATED and chargeback.substage == SUBSTAGE_TYPE_NO_ERRORS:

                # customer exist in acumatica ?
                if customer_accno not in list(map(itemgetter('value'), list(map(itemgetter('CustomerID'), acumatica_customers_ids_list.json())))):
                    cbs_with_wrong_customers.append({
                        'cbid': cbid,
                        'customer_accno': customer_accno,
                        'error': 'Customer account number does not exist in Acumatica'
                    })

                # items exist in acumatica ?
                my_items_dict = chargeback.get_my_items_dict_for_acumatica_or_ds365()
                for my_item_accno in my_items_dict.keys():
                    if my_item_accno not in list(map(itemgetter('value'), list(map(itemgetter('InventoryID'), acumatica_items_ids_list.json())))):
                        cbs_with_wrong_items.append({
                            'cbid': cbid,
                            'item_accno': my_item_accno,
                            'error': 'Item account number does not exist in Acumatica'
                        })

                # if company has enabled generate_transaction_number we generate the transaction_number from cbid and
                # it needs to validate if transaction number exist in acumatica
                transaction_type = 'Credit Memo' if cb_claim_amount_issue > 0 else 'Debit Memo'
                if data['company'].generate_transaction_number:
                    transaction_number = f"CB{cbid}"
                    # api to check transaction
                    response = rs.check_transaction(transaction_type, transaction_number)
                    if response.json():
                        cbs_with_existing_transactions.append({
                            'cbid': cbid,
                            'transaction_no': transaction_number,
                            'error': 'Transaction already exist in acumatica'
                        })

        if cbs_with_wrong_customers or cbs_with_wrong_items or cbs_with_existing_transactions:
            return bad_json(extradata={'cbs_with_wrong_customers': cbs_with_wrong_customers,
                                       'cbs_with_wrong_items': cbs_with_wrong_items,
                                       'cbs_with_existing_transactions': cbs_with_existing_transactions})

        return ok_json()

    except Exception as ex:
        return bad_json(message=ex.__str__())


@login_required(redirect_field_name='ret', login_url='/login')
@csrf_exempt
def acumatica_sending(request):
    data = {'title': 'Chargebacks - Post to Accounting - Acumatica Sending'}
    addGlobalData(request, data)

    try:
        chargebacks_ids = request.POST['chargebacks_ids']
        post_date = request.POST['post_date']

        # Send CBs (create transaction API)
        rs = AcumaticaRestService(config=data['company'].integration_config)
        if not rs.connected:
            return bad_json(message='Error connecting to Acumatica')

        cbs_with_transaction_errors = []
        cbs_with_transaction_success = []
        for chargeback_id in chargebacks_ids.split("|"):
            chargeback = ChargeBack.objects.get(id=chargeback_id)

            # Validation (Ticket EA-637) skips any CB that is not Stage 2, Substage 0
            # If CB already has Accounting info in the CM fields, it cannot be posted to accounting again (is skipped)
            # ticket 998 added condition: If a CB has pending lines, do not allow user to Post to accounting
            if not chargeback.has_chargebacks_lines_with_pending_status() and chargeback.stage == STAGE_TYPE_VALIDATED and chargeback.substage == SUBSTAGE_TYPE_NO_ERRORS and not chargeback.accounting_credit_memo_number and not chargeback.accounting_credit_memo_date:

                cb_claim_amount_issue = chargeback.claim_issue if chargeback.claim_issue else 0
                cbid = chargeback.cbid
                cb_number = chargeback.number
                customer = chargeback.get_my_customer()
                customer_accno = customer.account_number if customer else 'N/A'
                my_items_dict = chargeback.get_my_items_dict_for_acumatica_or_ds365()

                # Ticket: EA-593 When a CB has a zero Claim Amount do not include it in the Post Accounting action
                if cb_claim_amount_issue != 0:

                    # Ticket 741 - create record Accounting Transaction
                    acct_transaction = AccountingTransaction(cbid=cbid,
                                                             cb_number=cb_number,
                                                             cb_amount_issue=Decimal(cb_claim_amount_issue),
                                                             customer_accno=customer_accno,
                                                             post_date=convert_string_to_date(post_date),
                                                             integration_type='A',
                                                             status=ACCOUNTING_TRANSACTION_STATUS_SENT)
                    acct_transaction.save()

                    # API - Create Transaction in acumatica
                    response = rs.create_transaction(
                        customer_accno=customer_accno,
                        transaction_type='Credit Memo' if cb_claim_amount_issue > 0 else 'Debit Memo',
                        transaction_number=f'CB{cbid}' if data['company'].generate_transaction_number else '',
                        description=f"DM# {cb_number}",
                        post_date=f"{convert_string_to_date(post_date).strftime('%m/%d/%Y')}",
                        terms='00',
                        transaction_lines=[{
                                "InventoryID": {
                                    "value": k
                                },
                                "UnitPrice": {
                                    "value": float(v["item_unit_price"])
                                },
                                "Qty": {
                                    "value": int(v["item_sum_quantity"])
                                }
                            } for k, v in my_items_dict.items()
                        ])

                    if response:
                        response = response.json()

                        cm_number = response['ReferenceNbr']['value']
                        cm_amount = Decimal(response['Amount']['value']).quantize(Decimal(10) ** -2)

                        if cm_amount == cb_claim_amount_issue:
                            cbs_with_transaction_success.append({
                                'cbid': cbid,
                                'acct_transaction_id': acct_transaction.get_id_str(),
                                'cm_number': cm_number,
                                'cm_amount': float(cm_amount),
                            })
                        else:
                            cbs_with_transaction_errors.append({
                                'cbid': cbid,
                                'acct_transaction_id': acct_transaction.get_id_str(),
                                'error': f'Total amounts do not match (Acumatica Total: {cm_amount}, Chargeback Total: {cb_claim_amount_issue})',
                            })
                    else:
                        cbs_with_transaction_errors.append({
                            'cbid': cbid,
                            'acct_transaction_id': acct_transaction.get_id_str(),
                            'error': 'Error creating transaction',
                        })

                else:
                    acct_transaction = AccountingTransaction(cbid=cbid,
                                                             cb_number=cb_number,
                                                             cb_amount_issue=Decimal('0.00'),
                                                             customer_accno=customer_accno,
                                                             post_date=convert_string_to_date(post_date),
                                                             integration_type='A',
                                                             status=ACCOUNTING_TRANSACTION_STATUS_RECEIVED)
                    acct_transaction.save()

                    # Ticket 844 If nocredit Enabled, put NOCREDIT in CM field
                    # If Disabled, CM field put text NOCM concatenated with CBNumber (NOCM{CBnumber})
                    if customer.nocredit:
                        accounting_credit_memo_number = "NOCREDIT"
                    else:
                        accounting_credit_memo_number = f"NOCM{cb_number}"

                    chargeback.accounting_credit_memo_number = accounting_credit_memo_number
                    chargeback.accounting_credit_memo_amount = Decimal('0.00')
                    chargeback.accounting_credit_memo_date = convert_string_to_date(post_date)
                    chargeback.stage = STAGE_TYPE_POSTED
                    chargeback.substage = SUBSTAGE_TYPE_NO_ERRORS
                    chargeback.save()

                # Audit Trail
                # audit_trail(username=request.user.username,
                #             action=AUDIT_TRAIL_CHARGEBACK_ACTION_POST_TO_ACCOUNTING,
                #             ip_address=get_ip_address(request),
                #             entity1_name=chargeback.__class__.__name__,
                #             entity1_id=chargeback.get_id_str(),
                #             entity1_reference=chargeback.cbid)
                # EA -EA-1548 New Chargeback Audit
                change_text = f"{request.user.email} ran action {AUDIT_TRAIL_CHARGEBACK_ACTION_POST_TO_ACCOUNTING}"
                chargeback_audit_trails(cbid=chargeback.get_id_str(),
                                        user_email=request.user.email,
                                        change_text=change_text,
                                        )
        return ok_json(data={'cbs_with_transaction_success': cbs_with_transaction_success,
                             'cbs_with_transaction_errors': cbs_with_transaction_errors})

    except Exception as ex:
        return bad_json(message=ex.__str__())


@login_required(redirect_field_name='ret', login_url='/login')
@csrf_exempt
def acumatica_updating(request):
    data = {'title': 'Chargebacks - Post to Accounting - Acumatica Updating CBs'}
    addGlobalData(request, data)

    if not data['company'] or not data['has_access_to_company']:
        return HttpResponseRedirect(reverse('companies'))

    try:
        cbs_with_transaction_success = json.loads(request.POST['cbs_with_transaction_success'])
        cbs_with_transaction_errors = json.loads(request.POST['cbs_with_transaction_errors'])
        post_date = convert_string_to_date(request.POST['post_date'])

        for item in cbs_with_transaction_success:
            chargeback = ChargeBack.objects.get(cbid=item['cbid'])
            acct_transaction = AccountingTransaction.objects.get(id=item['acct_transaction_id'])
            cm_number = item['cm_number']
            cm_amount = Decimal(item['cm_amount']).quantize(Decimal(10) ** -2)

            # Chargeback fields are updated with the posting results, get values from acumatica api response
            chargeback.accounting_credit_memo_number = cm_number
            chargeback.accounting_credit_memo_amount = cm_amount
            chargeback.accounting_credit_memo_date = post_date
            chargeback.stage = STAGE_TYPE_POSTED
            chargeback.substage = SUBSTAGE_TYPE_NO_ERRORS
            chargeback.save()

            # update acct transaction
            acct_transaction.status = ACCOUNTING_TRANSACTION_STATUS_RECEIVED
            acct_transaction.save()

        for item in cbs_with_transaction_errors:
            chargeback = ChargeBack.objects.get(cbid=item['cbid'])
            cbid = item['cbid']
            error = item['error']
            acct_transaction = AccountingTransaction.objects.get(id=item['acct_transaction_id'])

            # change the CB Stage to POSTED and Substage to ERRORS if there is any error on the integration process
            chargeback.stage = STAGE_TYPE_POSTED
            chargeback.substage = SUBSTAGE_TYPE_ERRORS
            chargeback.save()

            # create accounting_error instance
            acct_error = AccountingError(accounting_transaction=acct_transaction,
                                         cbid=cbid,
                                         error=error)
            acct_error.save()

            # update acc_transaction with errors
            acct_transaction.has_error = True
            acct_transaction.save()

        return ok_json(data={'message': 'Integration process is completed'})

    except Exception as ex:
        return bad_json(message=ex.__str__())


# # # # # DYNAMICS365 Handler # # # # #
@login_required(redirect_field_name='ret', login_url='/login')
@csrf_exempt
def dynamics365_connection(request):
    data = {'title': 'Chargebacks - Post to Accounting - Dynamics365 Connection'}
    addGlobalData(request, data)
    try:
        rs = Dynamics365aRestService(config=data['company'].integration_config)
        if not rs.access_token:
            return bad_json(message='Error connecting to Dynamics365 ')
        return ok_json(data={'access_token': rs.access_token})
    except Exception as ex:
        return bad_json(message=ex.__str__())


@login_required(redirect_field_name='ret', login_url='/login')
@csrf_exempt
def dynamics365_validations(request):
    data = {'title': 'Chargebacks - Post to Accounting - Dynamics365 Validations'}
    addGlobalData(request, data)

    try:
        access_token = request.POST.get('access_token', '')
        rs = Dynamics365aRestService(config=data['company'].integration_config, access_token=access_token)
        ds365_customers_accno_list = []
        d365_items_ndc_list = []
        # Get DS365 Customers and Items for validations
        ds365_customers_accno_list = rs.get_customers_account_numbers()

        d365_items_ndc_list = rs.get_items_ndcs()

        cbs_with_wrong_customers = []
        cbs_with_wrong_items = []
        # cbs_with_existing_transactions = []
        for chargeback_id in request.POST['chargebacks_ids'].split("|"):
            chargeback = ChargeBack.objects.get(id=chargeback_id)
            cbid = chargeback.cbid
            customer = chargeback.get_my_customer()
            customer_accno = customer.account_number if customer else 'N/A'

            if chargeback.stage == STAGE_TYPE_VALIDATED and chargeback.substage == SUBSTAGE_TYPE_NO_ERRORS:

                # customer exist in ds365 ?
                if customer_accno not in ds365_customers_accno_list:
                    cbs_with_wrong_customers.append({
                        'cbid': cbid,
                        'customer_accno': customer_accno,
                        'error': 'Customer account number does not exist in Dynamics365'
                    })
                    # EA-1681 When posting chargebacks to D365 the status does not change to Posted w/ Errors if the chargebacks fail
                    chargeback.stage = STAGE_TYPE_POSTED
                    chargeback.substage = SUBSTAGE_TYPE_ERRORS
                    chargeback.save()

                # items exist in acumatica ?
                my_items_dict = chargeback.get_my_items_dict_for_acumatica_or_ds365()
                for my_item_accno in my_items_dict.keys():
                    if my_item_accno not in d365_items_ndc_list:
                        cbs_with_wrong_items.append({
                            'cbid': cbid,
                            'item_accno': my_item_accno,
                            'error': 'Item account number does not exist in Dynamics365'
                        })
                        # EA-1681 When posting chargebacks to D365 the status does not change to Posted w/ Errors if the chargebacks fail
                        chargeback.stage = STAGE_TYPE_POSTED
                        chargeback.substage = SUBSTAGE_TYPE_ERRORS
                        chargeback.save()

        if cbs_with_wrong_customers or cbs_with_wrong_items:
            return bad_json(extradata={'cbs_with_wrong_customers': cbs_with_wrong_customers,
                                       'cbs_with_wrong_items': cbs_with_wrong_items})

        return ok_json()

    except Exception as ex:
        return bad_json(message=ex.__str__())


@login_required(redirect_field_name='ret', login_url='/login')
@csrf_exempt
def dynamics365_sending_and_updating(request):
    data = {'title': 'Chargebacks - Post to Accounting - Dynamics365 Sending and Updating CM fields'}
    addGlobalData(request, data)

    try:
        chargebacks_ids = request.POST['chargebacks_ids']
        post_date = convert_string_to_date(request.POST['post_date'])

        access_token = request.POST.get('access_token', '')
        rs = Dynamics365aRestService(config=data['company'].integration_config, access_token=access_token)

        for chargeback_id in chargebacks_ids.split("|"):
            chargeback = ChargeBack.objects.get(id=chargeback_id)

            if not chargeback.has_chargebacks_lines_with_pending_status() and chargeback.stage == STAGE_TYPE_VALIDATED and chargeback.substage == SUBSTAGE_TYPE_NO_ERRORS and not chargeback.accounting_credit_memo_number and not chargeback.accounting_credit_memo_date:

                cb_claim_amount_issue = chargeback.claim_issue if chargeback.claim_issue else 0
                cbid = chargeback.cbid
                sales_order_number = f'CB{str(cbid).zfill(8)}'
                cb_number = chargeback.number
                customer = chargeback.get_my_customer()
                customer_accno = customer.account_number if customer else 'N/A'
                my_items_dict = chargeback.get_my_items_dict_for_acumatica_or_ds365()
                # EA-1474 - D365 change
                is_empower_dictates_numbers_to_d365 = True if data['company'].generate_transaction_number else False


                if cb_claim_amount_issue != 0:

                    acct_transaction = AccountingTransaction(cbid=cbid,
                                                             cb_number=cb_number,
                                                             cb_amount_issue=Decimal(cb_claim_amount_issue),
                                                             customer_accno=customer_accno,
                                                             post_date=post_date,
                                                             integration_type='D',
                                                             status=ACCOUNTING_TRANSACTION_STATUS_SENT)
                    acct_transaction.save()

                    # API - Create SaleOrder (CB) in ds365
                    soheader_response = rs.create_sale_order_header(sales_order_number=sales_order_number,
                                                                    customer_accno=customer_accno,
                                                                    cb_number=cb_number,
                                                                    is_empower_dictates_numbers_to_d365=is_empower_dictates_numbers_to_d365)

                    if soheader_response:
                        soheader_response_json = soheader_response.json()

                        soheader_cb_number = soheader_response_json["SalesOrderNumber"]

                        cm_amount = -Decimal(cb_claim_amount_issue).quantize(Decimal(10) ** -2)
                        # EA-1615 Amt posted to D365 is correct, but the CM Amount in Empower is showing negative instead of positive.
                        cb_cm_amount = Decimal(cb_claim_amount_issue).quantize(Decimal(10) ** -2)

                        # API - Create Lines SaleOrderLines (CBLine) in ds365
                        for k, v in my_items_dict.items():
                            soline_response = rs.create_sale_order_line(cb_number=sales_order_number if is_empower_dictates_numbers_to_d365 else soheader_cb_number,
                                                                        item_ndc=k,
                                                                        item_qty=-int(v["item_sum_quantity"]),
                                                                        line_amount=-float(v["item_sum_claim_amount_issue"]))

                            if not soline_response:
                                raise Exception(f'Error creating SalesOrderLine (Item: {k})')

                        # Chargeback fields are updated with the posting results, get values from ds365 response
                        chargeback.accounting_credit_memo_number = sales_order_number if is_empower_dictates_numbers_to_d365 else soheader_cb_number
                        chargeback.accounting_credit_memo_amount = cb_cm_amount
                        chargeback.accounting_credit_memo_date = post_date
                        chargeback.stage = STAGE_TYPE_POSTED
                        chargeback.substage = SUBSTAGE_TYPE_NO_ERRORS
                        chargeback.save()

                        # update acct transaction
                        acct_transaction.status = ACCOUNTING_TRANSACTION_STATUS_RECEIVED
                        acct_transaction.save()

                    else:
                        # change the CB Stage to POSTED and Substage to ERRORS if any error on the integration process
                        chargeback.stage = STAGE_TYPE_POSTED
                        chargeback.substage = SUBSTAGE_TYPE_ERRORS
                        chargeback.save()

                        # create accounting_error instance
                        acct_error = AccountingError(accounting_transaction=acct_transaction,
                                                     cbid=cbid,
                                                     error='Error creating SalesOrder in DS365')
                        acct_error.save()

                        # update acc_transaction with errors
                        acct_transaction.has_error = True
                        acct_transaction.save()

                else:
                    acct_transaction = AccountingTransaction(cbid=cbid,
                                                             cb_number=cb_number,
                                                             cb_amount_issue=Decimal('0.00'),
                                                             customer_accno=customer_accno,
                                                             post_date=post_date,
                                                             integration_type='D',
                                                             status=ACCOUNTING_TRANSACTION_STATUS_RECEIVED)
                    acct_transaction.save()

                    # Ticket 844 If nocredit Enabled, put NOCREDIT in CM field
                    # If Disabled, CM field put text NOCM concatenated with CBNumber (NOCM{CBnumber})
                    if customer.nocredit:
                        accounting_credit_memo_number = "NOCREDIT"
                    else:
                        accounting_credit_memo_number = f"NOCM{cb_number}"

                    chargeback.accounting_credit_memo_number = accounting_credit_memo_number
                    chargeback.accounting_credit_memo_amount = Decimal('0.00')
                    chargeback.accounting_credit_memo_date = post_date
                    chargeback.stage = STAGE_TYPE_POSTED
                    chargeback.substage = SUBSTAGE_TYPE_NO_ERRORS
                    chargeback.save()

                # Audit Trail
                # audit_trail(username=request.user.username,
                #             action=AUDIT_TRAIL_CHARGEBACK_ACTION_POST_TO_ACCOUNTING,
                #             ip_address=get_ip_address(request),
                #             entity1_name=chargeback.__class__.__name__,
                #             entity1_id=chargeback.get_id_str(),
                #             entity1_reference=chargeback.cbid)
                # EA-1548 New Chargeback Audit
                change_text = f"{request.user.email} ran action {AUDIT_TRAIL_CHARGEBACK_ACTION_POST_TO_ACCOUNTING}"
                chargeback_audit_trails(cbid=chargeback.get_id_str(),
                                        user_email=request.user.email,
                                        change_text=change_text,
                                        )
        return ok_json(data={'message': 'DS365 Integration process is completed'})

    except Exception as ex:
        return bad_json(message=ex.__str__())
